#!/usr/bin/env python

# Copyright 2020 Stanford University, Los Alamos National Laboratory
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# IMPORTANT:
#   * legion_cffi.py.in is used as an input to string.format()
#   * legion_cffi.py is a generated file and should not be modified by hand

from __future__ import absolute_import, division, print_function, unicode_literals

import cffi, os

from .flexflow_env import flexflow_python_interpreter

header = 'enum ActiMode {\n  AC_MODE_NONE = 10,\n  AC_MODE_RELU = 11,\n  AC_MODE_SIGMOID = 12,\n  AC_MODE_TANH = 13,\n  AC_MODE_GELU = 14,\n};\nenum AggrMode {\n  AGGR_MODE_NONE = 20,\n  AGGR_MODE_SUM = 21,\n  AGGR_MODE_AVG = 22,\n};\nenum PoolType {\n  POOL_MAX = 30,\n  POOL_AVG = 31,\n};\nenum DataType {\n  DT_FLOAT = 40,\n  DT_DOUBLE = 41,\n  DT_INT32 = 42,\n  DT_INT64 = 43,\n  DT_BOOLEAN = 44,\n  DT_NONE = 49,\n};\nenum LossType {\n  LOSS_CATEGORICAL_CROSSENTROPY = 50,\n  LOSS_SPARSE_CATEGORICAL_CROSSENTROPY = 51,\n  LOSS_MEAN_SQUARED_ERROR_AVG_REDUCE = 52,\n  LOSS_MEAN_SQUARED_ERROR_SUM_REDUCE = 53,\n};\nenum CompMode {\n  COMP_MODE_TRAINING = 70,\n  COMP_MODE_INFERENCE = 71,\n};\nenum ParameterSyncType {\n  NONE = 80,\n  PS = 81,\n  NCCL = 82,\n};\nenum MetricsType {\n  METRICS_ACCURACY = 1001,\n  METRICS_CATEGORICAL_CROSSENTROPY = 1002,\n  METRICS_SPARSE_CATEGORICAL_CROSSENTROPY = 1004,\n  METRICS_MEAN_SQUARED_ERROR = 1008,\n  METRICS_ROOT_MEAN_SQUARED_ERROR = 1016,\n  METRICS_MEAN_ABSOLUTE_ERROR = 1032,\n};\nenum OperatorType {\n  OP_INPUT,\n  OP_WEIGHT,\n  OP_ANY,\n  OP_CONV2D,\n  OP_DROPOUT,\n  OP_LINEAR,\n  OP_BATCHMATMUL,\n  OP_POOL2D,\n  OP_SCALAR_MULTIPLY,\n  OP_SCALAR_ADD,\n  OP_SCALAR_FLOOR_DIV,\n  OP_SCALAR_TRUE_DIV,\n  OP_SCALAR_SUB,\n  OP_RELU,\n  OP_IDENTITY,\n  OP_SIGMOID,\n  OP_TANH,\n  OP_ELU,\n  OP_FLAT,\n  OP_SOFTMAX,\n  OP_BATCHNORM,\n  OP_CONCAT,\n  OP_SPLIT,\n  OP_EMBEDDING,\n  OP_GROUP_BY,\n  OP_CACHE,\n  OP_AGGREGATE,\n  OP_AGG_SPEC,\n  OP_RESHAPE,\n  OP_REVERSE,\n  OP_TRANSPOSE,\n  OP_EW_ADD,\n  OP_EW_MUL,\n  OP_MATMUL,\n  OP_MUL,\n  OP_ENLARGE,\n  OP_MERGE_GCONV,\n  OP_CONSTANT_IMM,\n  OP_CONSTANT_ICONV,\n  OP_CONSTANT_ONE,\n  OP_CONSTANT_POOL,\n  OP_SQUEEZE,\n  OP_UNSQUEEZE,\n  OP_EW_SUB,\n  OP_EW_DIV,\n  OP_EW_EQUAL,\n  OP_EW_GREATER,\n  OP_EW_LESS,\n  OP_EW_MAX,\n  OP_EW_MIN,\n  OP_REDUCE_ARGMAX,\n  OP_REDUCE_ARGMIN,\n  OP_REDUCE_MAX,\n  OP_REDUCE_MEAN,\n  OP_REDUCE_MIN,\n  OP_REDUCE_PROD,\n  OP_REDUCE_SUM,\n  OP_PAD,\n  OP_SHAPE,\n  OP_SIZE,\n  OP_TOPK,\n  OP_WHERE,\n  OP_CEIL,\n  OP_CAST,\n  OP_EXP,\n  OP_ROUND,\n  OP_LOG,\n  OP_LOGICAL_NOT,\n  OP_SQRT,\n  OP_LEAKYRELU,\n  OP_SLICE,\n  OP_RESIZE,\n  OP_PRELU,\n  OP_GELU,\n  OP_MULTIHEAD_ATTENTION,\n  OP_FUSED,\n};\ntypedef struct flexflow_config_t { void *impl; } flexflow_config_t;\ntypedef struct flexflow_model_t { void *impl; } flexflow_model_t;\ntypedef struct flexflow_tensor_t { void *impl; } flexflow_tensor_t;\ntypedef struct flexflow_sgd_optimizer_t { void *impl; } flexflow_sgd_optimizer_t;\ntypedef struct flexflow_adam_optimizer_t { void *impl; } flexflow_adam_optimizer_t;\ntypedef struct flexflow_initializer_t { void *impl; } flexflow_initializer_t;\ntypedef struct flexflow_glorot_uniform_initializer_t { void *impl; } flexflow_glorot_uniform_initializer_t;\ntypedef struct flexflow_zero_initializer_t { void *impl; } flexflow_zero_initializer_t;\ntypedef struct flexflow_uniform_initializer_t { void *impl; } flexflow_uniform_initializer_t;\ntypedef struct flexflow_norm_initializer_t { void *impl; } flexflow_norm_initializer_t;\ntypedef struct flexflow_op_t { void *impl; } flexflow_op_t;\ntypedef struct flexflow_parameter_t { void *impl; } flexflow_parameter_t;\ntypedef struct flexflow_perf_metrics_t { void *impl; } flexflow_perf_metrics_t;\ntypedef struct flexflow_net_config_t { void *impl; } flexflow_net_config_t;\ntypedef struct flexflow_dlrm_config_t { void *impl; } flexflow_dlrm_config_t;\ntypedef struct flexflow_dataloader_4d_t { void *impl; } flexflow_dataloader_4d_t;\ntypedef struct flexflow_dataloader_2d_t { void *impl; } flexflow_dataloader_2d_t;\ntypedef struct flexflow_single_dataloader_t { void *impl; } flexflow_single_dataloader_t;\nflexflow_config_t\nflexflow_config_create(void);\nvoid\nflexflow_config_destroy(\n  flexflow_config_t handle);\nvoid\nflexflow_config_parse_args(\n  flexflow_config_t handle,\n  char** argv,\n  int argc);\nvoid\nflexflow_config_parse_args_default(\n  flexflow_config_t handle);\nint\nflexflow_config_get_batch_size(\n  flexflow_config_t handle);\nint\nflexflow_config_get_workers_per_node(\n  flexflow_config_t handle);\nint\nflexflow_config_get_num_nodes(\n  flexflow_config_t handle);\nint\nflexflow_config_get_epochs(\n  flexflow_config_t handle);\nbool\nflexflow_config_get_enable_control_replication(\n  flexflow_config_t handle);\nint\nflexflow_config_get_python_data_loader_type(\n  flexflow_config_t handle);\nflexflow_model_t\nflexflow_model_create(\n  flexflow_config_t config);\nvoid\nflexflow_model_destroy(\n  flexflow_model_t handle);\nvoid\nflexflow_model_reset_metrics(\n  flexflow_model_t handle);\nvoid\nflexflow_model_init_layers(\n  flexflow_model_t handle);\nvoid\nflexflow_model_prefetch(\n  flexflow_model_t handle);\nvoid\nflexflow_model_forward(\n  flexflow_model_t handle,\n  int seq_length);\nvoid\nflexflow_model_backward(\n  flexflow_model_t handle,\n  int seq_length);\nvoid\nflexflow_model_compute_metrics(\n  flexflow_model_t handle);\nvoid\nflexflow_model_update(\n  flexflow_model_t handle);\nvoid\nflexflow_model_compile(\n  flexflow_model_t handle,\n  enum LossType loss_type,\n  int *metrics,\n  int nb_metrics,\n  enum CompMode comp_mode);\nflexflow_tensor_t\nflexflow_model_get_label_tensor(\n  flexflow_model_t handle);\nvoid\nflexflow_model_zero_gradients(\n  flexflow_model_t handle);\nflexflow_tensor_t\nflexflow_model_add_exp(\n  flexflow_model_t handle,\n  const flexflow_tensor_t x,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_add(\n  flexflow_model_t handle,\n  const flexflow_tensor_t x,\n  const flexflow_tensor_t y,\n  bool inplace_a,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_subtract(\n  flexflow_model_t handle,\n  const flexflow_tensor_t x,\n  const flexflow_tensor_t y,\n  bool inplace_a,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_multiply(\n  flexflow_model_t handle,\n  const flexflow_tensor_t x,\n  const flexflow_tensor_t y,\n  bool inplace_a,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_divide(\n  flexflow_model_t handle,\n  const flexflow_tensor_t x,\n  const flexflow_tensor_t y,\n  bool inplace_a,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_conv2d(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  int out_channels,\n  int kernel_h, int kernel_w,\n  int stride_h, int stride_w,\n  int padding_h, int padding_w,\n  enum ActiMode activation ,\n  int groups,\n  bool use_bias ,\n  flexflow_op_t shared_op,\n  flexflow_initializer_t kernel_initializer,\n  flexflow_initializer_t bias_initializer,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_embedding(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  int num_entires, int out_dim,\n  enum AggrMode aggr,\n  flexflow_op_t shared_op,\n  flexflow_initializer_t kernel_initializer,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_pool2d(\n  flexflow_model_t handle,\n  flexflow_tensor_t input,\n  int kernel_h, int kernel_w,\n  int stride_h, int stride_w,\n  int padding_h, int padding_w,\n  enum PoolType type ,\n  enum ActiMode activation ,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_batch_norm(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  bool relu,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_batch_matmul(\n  flexflow_model_t handle,\n  const flexflow_tensor_t a,\n  const flexflow_tensor_t b,\n  int a_seq_length_dim ,\n  int b_seq_length_dim );\nflexflow_tensor_t\nflexflow_model_add_dense(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  int out_dim,\n  enum ActiMode activation ,\n  bool use_bias ,\n  flexflow_op_t shared_op,\n  flexflow_initializer_t kernel_initializer,\n  flexflow_initializer_t bias_initializer,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_concat(\n  flexflow_model_t handle,\n  int n,\n  flexflow_tensor_t* input,\n  int axis,\n  const char *name);\nvoid\nflexflow_model_add_split(\n  flexflow_model_t handle,\n  flexflow_tensor_t input,\n  int n,\n  flexflow_tensor_t* outputs,\n  int* split,\n  int axis,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_flat(\n  flexflow_model_t handle,\n  flexflow_tensor_t input,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_softmax(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  int dim,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_transpose(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  int n,\n  int* perm,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_reshape(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  int n,\n  int* shape,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_reverse(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  int axis,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_relu(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  bool inplace,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_scalar_multiply(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const float scalar,\n  bool inplace,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_scalar_add(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const float scalar,\n  bool inplace,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_scalar_sub(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const float scalar,\n  bool inplace,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_scalar_truediv(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const float scalar,\n  bool inplace,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_gelu(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_identity(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_sigmoid(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_tanh(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_elu(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  bool inplace,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_dropout(\n  flexflow_model_t handle,\n  const flexflow_tensor_t input,\n  float rate,\n  unsigned long long seed,\n  const char *name);\nflexflow_tensor_t\nflexflow_model_add_multihead_attention(\n  flexflow_model_t handle,\n  const flexflow_tensor_t query,\n  const flexflow_tensor_t key,\n  const flexflow_tensor_t value,\n  int embed_dim,\n  int num_heads,\n  int kdim,\n  int vdim,\n  float dropout,\n  bool bias,\n  bool add_bias_kv,\n  bool add_zero_attn,\n  flexflow_initializer_t kernel_initializer,\n  const char *name);\nvoid\nflexflow_model_set_sgd_optimizer(\n  flexflow_model_t handle,\n  flexflow_sgd_optimizer_t optimizer);\nvoid\nflexflow_model_set_adam_optimizer(\n  flexflow_model_t handle,\n  flexflow_adam_optimizer_t optimizer);\nvoid\nflexflow_model_print_layers(\n  flexflow_model_t handle,\n  int id);\nflexflow_op_t\nflexflow_model_get_layer_by_id(\n  flexflow_model_t handle,\n  int layer_id);\nflexflow_parameter_t\nflexflow_model_get_parameter_by_id(\n  flexflow_model_t handle,\n  int layer_id);\nflexflow_perf_metrics_t\nflexflow_model_get_perf_metrics(\n  flexflow_model_t handle);\nflexflow_tensor_t\nflexflow_tensor_create(\n  flexflow_model_t model,\n  int num_dims,\n  const int* dims,\n  enum DataType data_type,\n  bool create_grad );\nflexflow_tensor_t\nflexflow_constant_create(\n  flexflow_model_t model,\n  int num_dims,\n  const int* dims,\n  float value,\n  enum DataType data_type);\nvoid\nflexflow_tensor_destroy(\n  flexflow_tensor_t handle);\nvoid\nflexflow_tensor_inline_map(\n  flexflow_tensor_t handle,\n  flexflow_config_t config);\nvoid\nflexflow_tensor_inline_unmap(\n  flexflow_tensor_t handle,\n  flexflow_config_t config);\nfloat*\nflexflow_tensor_get_raw_ptr_float(\n  flexflow_tensor_t handle,\n  flexflow_config_t config);\nint32_t*\nflexflow_tensor_get_raw_ptr_int32(\n  flexflow_tensor_t handle,\n  flexflow_config_t config);\nint\nflexflow_tensor_get_num_dims(\n  flexflow_tensor_t handle);\nint*\nflexflow_tensor_get_dims(\n  flexflow_tensor_t handle);\nint\nflexflow_tensor_get_data_type(\n  flexflow_tensor_t handle);\nflexflow_op_t\nflexflow_tensor_get_owner_op(\n  flexflow_tensor_t handle);\nvoid\nflexflow_tensor_attach_raw_ptr(\n  flexflow_tensor_t handle,\n  flexflow_config_t config,\n  void *raw_ptr,\n  bool column_major);\nvoid\nflexflow_tensor_detach_raw_ptr(\n  flexflow_tensor_t handle,\n  flexflow_config_t config);\nbool\nflexflow_tensor_is_mapped(\n  flexflow_tensor_t handle);\nbool\nflexflow_tensor_set_tensor_float(\n  flexflow_tensor_t handle,\n  flexflow_model_t model,\n  int num_dim,\n  int *dims,\n  const float *data,\n  enum ParameterSyncType comm_type);\nbool\nflexflow_tensor_get_tensor_float(\n  flexflow_tensor_t handle,\n  flexflow_model_t model,\n  float *data,\n  enum ParameterSyncType comm_type);\nbool\nflexflow_tensor_set_tensor_int(\n  flexflow_tensor_t handle,\n  flexflow_model_t model,\n  int num_dim,\n  int *dims,\n  const int *data,\n  enum ParameterSyncType comm_type);\nbool\nflexflow_tensor_get_tensor_int(\n  flexflow_tensor_t handle,\n  flexflow_model_t model,\n  int *data,\n  enum ParameterSyncType comm_type);\nbool\nflexflow_parameter_set_weights_float(\n  flexflow_parameter_t handle,\n  flexflow_model_t model,\n  int num_dim,\n  int *dims,\n  const float *data);\nbool\nflexflow_parameter_get_weights_float(\n  flexflow_parameter_t handle,\n  flexflow_model_t model,\n  float *data);\nflexflow_sgd_optimizer_t\nflexflow_sgd_optimizer_create(\n  flexflow_model_t model,\n  double lr,\n  double momentum,\n  bool nesterov,\n  double weight_decay );\nvoid\nflexflow_sgd_optimizer_destroy(\n  flexflow_sgd_optimizer_t handle);\nvoid\nflexflow_sgd_optimizer_set_lr(\n  flexflow_sgd_optimizer_t handle,\n  double lr);\nflexflow_adam_optimizer_t\nflexflow_adam_optimizer_create(\n  flexflow_model_t model,\n  double alpha ,\n  double beta1 ,\n  double beta2 ,\n  double weight_decay ,\n  double epsilon );\nvoid\nflexflow_adam_optimizer_destroy(\n  flexflow_adam_optimizer_t handle);\nvoid\nflexflow_adam_optimizer_set_lr(\n  flexflow_adam_optimizer_t handle,\n  double lr);\nflexflow_initializer_t\nflexflow_initializer_create_null();\nflexflow_glorot_uniform_initializer_t\nflexflow_glorot_uniform_initializer_create(\n  int seed);\nvoid\nflexflow_glorot_uniform_initializer_destroy(\n  flexflow_glorot_uniform_initializer_t handle);\nflexflow_zero_initializer_t\nflexflow_zero_initializer_create(void);\nvoid\nflexflow_zero_initializer_destroy(\n  flexflow_zero_initializer_t handle);\nflexflow_uniform_initializer_t\nflexflow_uniform_initializer_create(\n  int seed,\n  float min,\n  float max);\nvoid\nflexflow_uniform_initializer_destroy(\n  flexflow_uniform_initializer_t handle);\nflexflow_norm_initializer_t\nflexflow_norm_initializer_create(\n  int seed,\n  float mean,\n  float stddev);\nvoid\nflexflow_norm_initializer_destroy(\n  flexflow_norm_initializer_t handle);\nvoid\nflexflow_per_metrics_destroy(\n  flexflow_perf_metrics_t handle);\nfloat\nflexflow_per_metrics_get_accuracy(\n  flexflow_perf_metrics_t handle);\nflexflow_net_config_t\nflexflow_net_config_create();\nvoid\nflexflow_net_config_destroy(\n  flexflow_net_config_t handle);\nconst char*\nflexflow_net_config_get_dataset_path(\n  flexflow_net_config_t handle);\nflexflow_dlrm_config_t\nflexflow_dlrm_config_create();\nvoid\nflexflow_dlrm_config_destroy(\n  flexflow_dlrm_config_t handle);\nconst char*\nflexflow_dlrm_config_get_dataset_path(\n  flexflow_dlrm_config_t handle);\nconst char*\nflexflow_dlrm_config_get_arch_interaction_op(\n  flexflow_dlrm_config_t handle);\nint\nflexflow_dlrm_config_get_sparse_feature_size(\n  flexflow_dlrm_config_t handle);\nint\nflexflow_dlrm_config_get_sigmoid_bot(\n  flexflow_dlrm_config_t handle);\nint\nflexflow_dlrm_config_get_sigmoid_top(\n  flexflow_dlrm_config_t handle);\nint\nflexflow_dlrm_config_get_embedding_bag_size(\n  flexflow_dlrm_config_t handle);\nfloat\nflexflow_dlrm_config_get_loss_threshold(\n  flexflow_dlrm_config_t handle);\nint*\nflexflow_dlrm_config_get_mlp_bot(\n  flexflow_dlrm_config_t handle);\nint*\nflexflow_dlrm_config_get_mlp_top(\n  flexflow_dlrm_config_t handle);\nint*\nflexflow_dlrm_config_get_embedding_size(\n  flexflow_dlrm_config_t handle);\nflexflow_dataloader_4d_t\nflexflow_dataloader_4d_create(\n  flexflow_model_t ffmodel,\n  flexflow_net_config_t netconfig,\n  flexflow_tensor_t input,\n  flexflow_tensor_t label);\nflexflow_dataloader_4d_t\nflexflow_dataloader_4d_create_v2(\n  flexflow_model_t ffmodel,\n  flexflow_tensor_t input,\n  flexflow_tensor_t label,\n  flexflow_tensor_t full_input,\n  flexflow_tensor_t full_label,\n  int num_samples);\nvoid\nflexflow_dataloader_4d_destroy(\n  flexflow_dataloader_4d_t handle);\nvoid\nflexflow_dataloader_4d_set_num_samples(\n  flexflow_dataloader_4d_t handle,\n  int samples);\nint\nflexflow_dataloader_4d_get_num_samples(\n  flexflow_dataloader_4d_t handle);\nvoid\nflexflow_dataloader_4d_reset(\n  flexflow_dataloader_4d_t handle);\nvoid\nflowflow_dataloader_4d_next_batch(\n  flexflow_dataloader_4d_t handle,\n  flexflow_model_t ffmodel);\nflexflow_dataloader_2d_t\nflexflow_dataloader_2d_create_v2(\n  flexflow_model_t ffmodel,\n  flexflow_tensor_t input,\n  flexflow_tensor_t label,\n  flexflow_tensor_t full_input,\n  flexflow_tensor_t full_label,\n  int num_samples);\nvoid\nflexflow_dataloader_2d_destroy(\n  flexflow_dataloader_2d_t handle);\nvoid\nflexflow_dataloader_2d_set_num_samples(\n  flexflow_dataloader_2d_t handle,\n  int samples);\nint\nflexflow_dataloader_2d_get_num_samples(\n  flexflow_dataloader_2d_t handle);\nvoid\nflexflow_dataloader_2d_reset(\n  flexflow_dataloader_2d_t handle);\nvoid\nflowflow_dataloader_2d_next_batch(\n  flexflow_dataloader_2d_t handle,\n  flexflow_model_t ffmodel);\nflexflow_single_dataloader_t\nflexflow_single_dataloader_create(\n  flexflow_model_t ffmodel,\n  flexflow_tensor_t input,\n  flexflow_tensor_t full_input,\n  int num_samples,\n  enum DataType data_type);\nflexflow_single_dataloader_t\nflexflow_single_dataloader_create2(\n  flexflow_model_t ffmodel,\n  flexflow_tensor_t input,\n  void *full_input_ptr,\n  int num_samples,\n  enum DataType data_type);\nvoid\nflexflow_single_dataloader_destroy(\n  flexflow_single_dataloader_t handle);\nvoid\nflexflow_single_dataloader_set_num_samples(\n  flexflow_single_dataloader_t handle,\n  int samples);\nint\nflexflow_single_dataloader_get_num_samples(\n  flexflow_single_dataloader_t handle);\nvoid\nflexflow_single_dataloader_reset(\n  flexflow_single_dataloader_t handle);\nvoid\nflowflow_single_dataloader_next_batch(\n  flexflow_single_dataloader_t handle,\n  flexflow_model_t ffmodel);\ndouble\nflexflow_get_current_time(\n  flexflow_config_t config);\nvoid\nflexflow_begin_trace(\n  flexflow_config_t config,\n  int trace_id);\nvoid\nflexflow_end_trace(\n  flexflow_config_t config,\n  int trace_id);\nint\nflexflow_op_get_num_parameters(\n  flexflow_op_t handle);\nflexflow_parameter_t\nflexflow_op_get_parameter_by_id(\n  flexflow_op_t handle,\n  int id);\nint\nflexflow_op_get_num_inputs(\n  flexflow_op_t handle);\nflexflow_tensor_t\nflexflow_op_get_input_by_id(\n  flexflow_op_t handle,\n  int id);\nint\nflexflow_op_get_num_outputs(\n  flexflow_op_t handle);\nflexflow_tensor_t\nflexflow_op_get_output_by_id(\n  flexflow_op_t handle,\n  int id);\nvoid\nflexflow_op_init(\n  flexflow_op_t handle,\n  flexflow_model_t model);\nvoid\nflexflow_op_forward(\n  flexflow_op_t handle,\n  flexflow_model_t model);\nvoid\nregister_c_custom_tasks();\n'
libname = 'flexflow_pybind11_internal.cpython-38-x86_64-linux-gnu.so'

ffi = cffi.FFI()
ffi.cdef(header)
if flexflow_python_interpreter() == 'native':
  if 'PYTHONPATH' in os.environ:
    python_paths = os.environ['PYTHONPATH'].split(':')
    flexflow_lib = '/flexflow/core/' + libname
    for p in python_paths:
      flexflow_lib_p = p + flexflow_lib
      if os.path.exists(flexflow_lib_p):
        flexflow_lib = flexflow_lib_p
        break
  else:
    flexflow_lib = 'flexflow/core/' + libname
else:
  flexflow_lib = None
ffc = ffi.dlopen(flexflow_lib)
